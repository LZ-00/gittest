<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://lz-00.github.io/blog</id>
    <title>Gridea</title>
    <updated>2021-04-16T03:44:21.985Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://lz-00.github.io/blog"/>
    <link rel="self" href="https://lz-00.github.io/blog/atom.xml"/>
    <subtitle>一起成长，一起记录</subtitle>
    <logo>https://lz-00.github.io/blog/images/avatar.png</logo>
    <icon>https://lz-00.github.io/blog/favicon.ico</icon>
    <rights>All rights reserved 2021, Gridea</rights>
    <entry>
        <title type="html"><![CDATA[SpringBoot]]></title>
        <id>https://lz-00.github.io/blog/post/springboot/</id>
        <link href="https://lz-00.github.io/blog/post/springboot/">
        </link>
        <updated>2021-04-15T16:24:05.000Z</updated>
        <content type="html"><![CDATA[<hr>
<p>title: Spring Boot<br>
date: 2020-09-04 15:48:18<br>
tags: Spring技术栈<br>
categories: 框架</p>
<hr>
<h2 id="一-spring-boot入门">一、Spring Boot入门</h2>
<h4 id="1springboot简介">1.SpringBoot简介</h4>
<p>​	简化Spring应用开发的一个框架；</p>
<p>​	整个Spring技术栈的一个大整合；</p>
<p>​	J2EE开发的一站式解决方案</p>
<img src="C:\Users\乐。\OneDrive\文档\有道云笔记\qq095E4186BB0C52B7F67283CEC83D7FF4\09ba66ecaee040388829d4e857831b8d\clipboard.png" alt="img" style="zoom:55%;" />
<h4 id="2微服务">2.微服务、</h4>
<p>​		2014，martin fowler</p>
<p>​	微服务：架构风格（服务微化）</p>
<p>​	一个应用应该是一组小型服务；可以通过http的方式进行互通；</p>
<p>​	每一个功能元素始终都是一个可独立替换和独立升级的软件单元；</p>
<h4 id="3在创建helloworld项目时添加">3.在创建HelloWorld项目时，添加：</h4>
<pre><code class="language-xml">&lt;profile&gt;
        &lt;id&gt;jdk-1.8&lt;/id&gt;
        &lt;activation&gt;
            &lt;activeByDefault&gt;true&lt;/activeByDefault&gt;
            &lt;jdk&gt;1.8&lt;/jdk&gt;
        &lt;/activation&gt;
        &lt;properties&gt;
            &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt;
            &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt;
            &lt;maven.compiler.compilerVersion&gt;1.8&lt;/maven.compiler.compilerVersion&gt;
        &lt;/properties&gt;
    &lt;/profile&gt;
 &lt;mirrors&gt;
      &lt;mirror&gt;
          &lt;id&gt;alimaven&lt;/id&gt;
          &lt;name&gt;aliyun maven&lt;/name&gt;
          　　&lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt;
          &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;
      &lt;/mirror&gt;
  &lt;/mirrors&gt;
</code></pre>
<h4 id="4创建一个helloworld的实例">4.创建一个HelloWorld的实例</h4>
<p>​	1.创建一个Maven的project</p>
<p>​	2.导入SpringBoot相关依赖：</p>
<pre><code class="language-xml">&lt;parent&gt;
	&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
	&lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
	&lt;version&gt;2.1.7.RELEASE&lt;/version&gt;
	&lt;/parent&gt;
	&lt;dependencies&gt;
	&lt;dependency&gt;
		&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
		&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
	&lt;/dependency&gt;
	&lt;/dependencies&gt;

	&lt;build&gt;
		&lt;plugins&gt;
			&lt;plugin&gt;
				&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
				&lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
			&lt;/plugin&gt;
		&lt;/plugins&gt;
	&lt;/build&gt;
</code></pre>
<p>​	3.编写一个主程序用来启动SpringBoot</p>
<p>​	4.编写一个相关的Controller、Service</p>
<p>​	5.运行主程序</p>
<h4 id="5helloworld探究">5.HelloWorld探究</h4>
<h5 id="1pom文件">1.POM文件</h5>
<h6 id="1父项目">1.父项目</h6>
<pre><code class="language-xml">&lt;parent&gt;
	&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
	&lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
	&lt;version&gt;2.1.7.RELEASE&lt;/version&gt;
&lt;/parent&gt;
他的父项目是：
&lt;parent&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt;
    &lt;version&gt;2.1.7.RELEASE&lt;/version&gt;
    &lt;relativePath&gt;../../spring-boot-dependencies&lt;/relativePath&gt;
  &lt;/parent&gt;
他来真正管理SpringBoot应用里面的所有依赖版本
</code></pre>
<p>Spring Boot的版本仲裁中心；</p>
<p>以后我们导入依赖默认是不需要写版本</p>
<h6 id="2导入的依赖">2.导入的依赖</h6>
<pre><code class="language-xml">&lt;dependencies&gt;
	&lt;dependency&gt;
		&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
		&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
	&lt;/dependency&gt;
	&lt;/dependencies&gt;
</code></pre>
<p>spring-boot-starter-web：spring boot场景启动器（帮我们导入web模块正常运行所依赖的组件）</p>
<p>Spring Boot将所有的功能场景都抽取出来，做成了一个个的启动器；只需在项目里引入starter相关场景的启动器，所有的依赖都会导到进来</p>
<h5 id="2主程序类入口类">2.主程序类，入口类</h5>
<pre><code class="language-java">@SpringBootApplication
public class HelloWorldMainApplication {  
    public static void main(String[] args) {      SpringApplication.run(HelloWorldMainApplication.class,args);   
                                                       }
                                                      }
</code></pre>
<p>​	@<strong>SpringBootApplication</strong>：Spring Boot应用标注在某个类上说明该类是SpringBoot的主配置类，SpringBoot就会运行这个类的main方法来启动SpringBoot应用</p>
<pre><code class="language-java">@Target({ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@SpringBootConfiguration
@EnableAutoConfiguration
@ComponentScan(
    excludeFilters = {@Filter(
    type = FilterType.CUSTOM,
    classes = {TypeExcludeFilter.class}
), @Filter(
    type = FilterType.CUSTOM,
    classes = {AutoConfigurationExcludeFilter.class}
)}
)
</code></pre>
<p>​	@<strong>SpringBootConfiguration</strong>:SpringBoot的配置类；</p>
<p>​			标注在某个类上，表示该类是SpringBoot的配置类</p>
<p>​			@<strong>Configuration</strong>：配置类上标注这个注解；</p>
<p>​					配置类------配置文件；配置类也是容器中的组件</p>
<p>​	@<strong>EnableAutoConfiguration</strong>：开启自动配置功能；</p>
<p>​			以前我们需要配置的东西，SpringBoot帮我们自动配置；		@EnableAutoConfiguration告知SpringBoot开启自动配置功能；这样自动配置才能生效；</p>
<pre><code class="language-java">@AutoConfigurationPackage
@Import({AutoConfigurationImportSelector.class})
</code></pre>
<p>​	@<strong>AutoConfigurationPackage</strong>：自动配置包</p>
<p>​		@Import({AutoConfigurationImportSelector.class})</p>
<p>​		Spring的底层注解@Import，给容器中导入一个组件；导入的组件由AutoConfigurationImportSelector.class；</p>
<p><strong>将主配置类所在的包以及所有子包里的组件扫描到Spring容器中</strong></p>
<p>​	<strong>@Import({AutoConfigurationImportSelector.class})</strong>；</p>
<p>​		给容器中导入组件</p>
<p>​		<strong>AutoConfigurationImportSelector</strong>：导入哪些组件的选择器</p>
<p>​		将所有需要导入的组件以全类名的方式返回；这些组件就会配添加到容器中</p>
<p>​		给容器中导入非常多的自动配置类（xxxAutoConfiguration）就是给容器中导入这个场景需要的所有组件，并配置好这些组件；</p>
<p>​		有了自动配置类，免去了我们手动编写配置注入功能组件的工作</p>
<p>​				SpringFactoriesLoader.loadFactoryNames(this.getSpringFactoriesLoaderFactoryClass(), this.getBeanClassLoader());</p>
<p>​			Spring Boot在启动时从类路径下的META-INF/spring.factories中获取EnableAutoConfiguration的值，将这些值作为自动配置类导入到容器中，自动配置类就生效了，帮我们启动自动配置的功能</p>
<h4 id="6使用spring-initializer快速创建spring-boot">6.使用Spring Initializer快速创建Spring Boot</h4>
<p>选择我们需要的模块；想到会联网创建SpringBoot项目；</p>
<p>默认生成的Spring Boot的项目：</p>
<p>​	1.主程序已生成，我们只需编写自己所需的逻辑</p>
<p>​	2.resources文件夹中的目录结构</p>
<p>​		static：保存所有的静态资源；js,css,images;</p>
<p>​		templates:保存所有的模板页面了（Spring Boot默认jar包不支持使用jsp页面，使用嵌入式的tomcat）；可以使用模板引擎（freemarker、thymeleaf）</p>
<p>​		application.propertiesSpring Boot应有的配置文件；可以修改一些默认配置</p>
<h4 id="7-一些依赖">7、一些依赖</h4>
<pre><code class="language-java"> 		&lt;!-- 引入jquery依赖 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.webjars&lt;/groupId&gt;
            &lt;artifactId&gt;jquery&lt;/artifactId&gt;
            &lt;version&gt;3.3.1-1&lt;/version&gt;
        &lt;/dependency&gt;
        
         &lt;!--引入thymeleaf依赖--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;
        &lt;/dependency&gt;
            
        &lt;!--引入bootstrap依赖--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.webjars&lt;/groupId&gt;
            &lt;artifactId&gt;bootstrap&lt;/artifactId&gt;
            &lt;version&gt;4.0.0&lt;/version&gt;
        &lt;/dependency&gt;
            
         &lt;!--引入jsondatabind依赖--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;
            &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;
            &lt;artifactId&gt;jackson-core&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;
            &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt;
        &lt;/dependency&gt;
            
        &lt;!--引入DruidDataSource--&gt;
        &lt;!-- https://mvnrepository.com/artifact/com.alibaba/druid --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
            &lt;artifactId&gt;druid&lt;/artifactId&gt;
            &lt;version&gt;1.1.23&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!-- https://mvnrepository.com/artifact/log4j/log4j --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;log4j&lt;/groupId&gt;
            &lt;artifactId&gt;log4j&lt;/artifactId&gt;
            &lt;version&gt;1.2.17&lt;/version&gt;
        &lt;/dependency&gt;
            
         &lt;!--lombok依赖--&gt;
        &lt;!-- https://mvnrepository.com/artifact/org.projectlombok/lombok --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
            &lt;artifactId&gt;lombok&lt;/artifactId&gt;
            &lt;version&gt;1.18.12&lt;/version&gt;
            &lt;scope&gt;provided&lt;/scope&gt;
        &lt;/dependency&gt;
        
</code></pre>
<h4 id="8-一些配置">8、一些配置</h4>
<pre><code class="language-properties">jdbc.driver=com.mysql.cj.jdbc.Driver
jdbc.url=jdbc:mysql://localhost/mybatis?serverTimezone=Asia/Shanghai&amp;allowMultiQueries=true
jdbc.username=root
jdbc.password=lizhuo21321
----------------------------------------------------
#mybatis-config:
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE configuration
  PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;
  &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;
&lt;configuration&gt;
  &lt;environments default=&quot;development&quot;&gt;
    &lt;environment id=&quot;development&quot;&gt;
      &lt;transactionManager type=&quot;JDBC&quot;/&gt;
      &lt;dataSource type=&quot;POOLED&quot;&gt;
        &lt;property name=&quot;driver&quot; value=&quot;${driver}&quot;/&gt;
        &lt;property name=&quot;url&quot; value=&quot;${url}&quot;/&gt;
        &lt;property name=&quot;username&quot; value=&quot;${username}&quot;/&gt;
        &lt;property name=&quot;password&quot; value=&quot;${password}&quot;/&gt;
      &lt;/dataSource&gt;
    &lt;/environment&gt;
  &lt;/environments&gt;
  &lt;mappers&gt;
    &lt;mapper resource=&quot;org/mybatis/example/BlogMapper.xml&quot;/&gt;
  &lt;/mappers&gt;
&lt;/configuration&gt;

&lt;settings&gt;
        &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&gt;
&lt;/settings&gt;
---------------------------------------------------
#mapper.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper
        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper&gt;
    
&lt;/mapper&gt;
---------------------------------------------------

</code></pre>
<h4 id="9-spring配置">9、Spring..配置</h4>
<pre><code class="language-java">//配置data绑定
/*
@Configuration
public class DataConfig implements WebBindingInitializer {

    @Override
    public void initBinder(WebDataBinder webDataBinder) {
        DateFormat dateFormat=new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);
        webDataBinder.registerCustomEditor(Date.class, new CustomDateEditor(dateFormat, true));
    }
}*/
 @InitBinder
    protected void initBinder(WebDataBinder binder) {
        SimpleDateFormat dateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);
        binder.registerCustomEditor(Date.class, new CustomDateEditor(dateFormat, true));
    }
-----------------------------------------------------
   @DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;)
   @JsonFormat(pattern = &quot;yyyy-MM-dd&quot;)
   private Date dTime;
------------------------------------------------------
//配置multiStatemenrt为true    		  @ConfigurationProperties(prefix = &quot;spring.datasource&quot;)
    @Bean
    public DataSource druidDataSource() {
        List&lt;Filter&gt; filters = new ArrayList&lt;&gt;();
        WallConfig config = new WallConfig();
        WallFilter wallFilter = new WallFilter();
        config.setMultiStatementAllow(true);
        wallFilter.setConfig(config);
        filters.add(wallFilter);
        DruidDataSource druidDataSource = new DruidDataSource();
        druidDataSource.setProxyFilters(filters);
        return druidDataSource;
    }
</code></pre>
<h2 id="二-配置文件">二、配置文件</h2>
<h4 id="1配置文件">1.配置文件</h4>
<p><strong>两种配置文件的优先级</strong>:</p>
<p>优先读取properties文件，如果properties文件中没有再去读yml文件。</p>
<pre><code class="language-java">application.properties(或者application.yml)中包含系统属性、环境变量、命令参数这类信息。
application.yml代码量 更少，层次更加分明，结构更加清晰，推荐使用application.yml
</code></pre>
<p>SpringBoot使用一个全局配置文件，配置文件名是固定的；</p>
<p>application.properties</p>
<p>application.yml</p>
<p>配置文件的使用：修改Spring Boot自动配置的默认值；</p>
<p>YAML（YAML Ain't Markup Language）</p>
<p>​		YAML A Markup Language：是一个标记语言</p>
<p>​		YAML isn't Markup Language</p>
<p>标记语言：</p>
<p>​		以前的配置文件；大多使用的是xxx.xml文件；</p>
<p>​		YAML：<strong>以数据为中心</strong>，比json、xml等更适合做配置文件</p>
<p>​		YAML：配置例子</p>
<pre><code class="language-yaml">server:
	port:8081
</code></pre>
<p>​	XML：</p>
<pre><code class="language-xml">&lt;server&gt;
	&lt;port&gt;8081&lt;/port&gt;
&lt;/server&gt;
</code></pre>
<h4 id="2yaml语法">2.YAML语法</h4>
<h5 id="1基本语法">1.基本语法</h5>
<p>k:(空格)v:表示一对键值对（空格必须有）；</p>
<p>以空格的缩进来控制层级关系；只要是左对齐的数据，都是同一层级的</p>
<pre><code class="language-yaml">server：
	port: 8081
	path: /hello
</code></pre>
<h5 id="2-值的写法">2、值的写法</h5>
<h6 id="字面量普通的值"><strong>字面量：普通的值</strong></h6>
<p>​	k: v: 字面量</p>
<p>​		字符串默认不用写双引号或者单引号；</p>
<p>​		&quot;&quot;：双引号不会转义特殊字符</p>
<p>​			name: &quot;lisi\lihua&quot; 输出：lisi换行lihua</p>
<p>​		''：name: &quot;lisi\lihua&quot; 输出：lisi\nlihua</p>
<h6 id="对象-map属性和值键值对">对象、Map（属性和值）（键值对）:</h6>
<p>​	k: v: 在下一行来写对象的属性和值的关系；注意缩进</p>
<p>​		对象还是k: v: 的方式</p>
<pre><code class="language-yaml">friends:
	lastname: lisi
	age: 20
</code></pre>
<p>行内写法：</p>
<pre><code class="language-yaml">friends: {lastname: lisi,age: 20}
</code></pre>
<h6 id="数组list-set">数组（List、Set）：</h6>
<p>用-值表示数组中的一个元素</p>
<pre><code class="language-yaml">pets:
 - cat
 - dog
 - pig
</code></pre>
<p>行内写法：</p>
<pre><code class="language-yaml">pets: [cat,dog,pig]
</code></pre>
<h4 id="3配置文件值注入">3.配置文件值注入</h4>
<p>配置文件：</p>
<pre><code class="language-yaml">server:
  port: 8081
person:
  last-name: 明天
  age: 20
  boss: false
  birth: 2017/09/02
  maps: {k1: pp,k2: ll}
  lists:
    - lisi
    - mingtian
  dog:
    name: 小狗
    age: 2

</code></pre>
<p>Java Bean:</p>
<pre><code class="language-java">/**
 * 将配置文件中每一个配置的属性的值映射到这个组件中
 * @ConfigurationProperties：告知Spring Boot将本类中的所有属性与配置文件中的相关属性进行绑定；
 * 		prefix = &quot;person&quot;：配置文件中那个属性下面的所有属性进行一一映射
 * 需加@Component，只有该组件是容器中的组件，才能通过@ConfigurationProperties功能
 */
@Component
@ConfigurationProperties(prefix = &quot;person&quot;)
public class Person {
	private String lastName;
	private Integer age;
	private boolean boss;
	private Date birth;

	private Map&lt;String,Object&gt; maps;
	private List&lt;Object&gt; lists;
	private Dog dog;

</code></pre>
<p>我们还可以导入配置文件处理器，在配置文件时就有提示</p>
<pre><code class="language-xml">&lt;dependency&gt;
	&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
	&lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt;
	&lt;optional&gt;true&lt;/optional&gt;
&lt;/dependency&gt;
</code></pre>
<h5 id="1configurationproperties和value获取值比较">1.@ConfigurationProperties和@Value获取值比较</h5>
<table>
<thead>
<tr>
<th></th>
<th>@ConfigurationProperties</th>
<th>@Value</th>
</tr>
</thead>
<tbody>
<tr>
<td>功能</td>
<td>批量注入配置文件中的属性</td>
<td>一个一个地注入</td>
</tr>
<tr>
<td>松散绑定（松散语法）</td>
<td>支持</td>
<td>不支持</td>
</tr>
<tr>
<td>SpEL</td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td>JSR303数据校验</td>
<td>支持</td>
<td>不支持</td>
</tr>
<tr>
<td>复杂类型封装</td>
<td>支持</td>
<td>不支持</td>
</tr>
</tbody>
</table>
<p>配置文件yaml还是properties他们都能获取到值</p>
<p>如果说，我们只是在某个业务逻辑中需要获取一下配置文件中的某项值，使用@value注解</p>
<p>如果说，我们专门写了一个javaBean来和配置文件进行映射；就是使用@ConfigurationProperties注解</p>
<h5 id="2propertysourceimportresource">2.@PropertySource&amp;@ImportResource</h5>
<p><strong>@PropertySource</strong>：加载指定的配置文件；</p>
<pre><code class="language-java">@PropertySource(value = {&quot;classpath:static/person.properties&quot;})
</code></pre>
<p><strong>@ImportResource</strong>：导入Spring配置文件，让配置文件中的内容生效；该注解标注在一个<strong>配置类</strong>上</p>
<pre><code class="language-java">@ImportResource(locations = {&quot;classpath:bean.xml&quot;})
导入Spring配置文件让其生效
</code></pre>
<p><strong>Spring Boot推荐使用全注解的方式</strong>为容器中注入bean</p>
<p>1、配置类======Spring配置文件</p>
<p>2、使用@Bean给容器添加组件</p>
<pre><code class="language-java">/**
 * @Configuration：指明该类是一个配置类，替换xml文件
 */
@Configuration
public class MyAppConfig {

	/**
	 * 将该方法的返回值添加到容器中，该bean的id值为方法值
	 * @return
	 */
	@Bean
	public HelloService helloService01(){
		return new HelloService();
	}
}
</code></pre>
<h4 id="4-配置文件占位符">4、配置文件占位符</h4>
<h5 id="1-随机数">1、随机数</h5>
<pre><code class="language-properties">${random.value},${random.int}...
</code></pre>
<h5 id="2-占位符获取之前配置的值如果没有可以使用指定的默认值">2、占位符获取之前配置的值，如果没有可以使用：指定的默认值</h5>
<pre><code class="language-properties">person.last-name=李四_${random.value}
person.age=${random.int}
person.birth=2017/02/09
person.boss=false
person.maps.k1=CC
person.maps.k2=VV
person.dog.name=${person.hello:hello}_小狗
person.dog.age=2
person.lists=1,2,3,4
</code></pre>
<h4 id="5-profile">5、Profile</h4>
<h6 id="1-多profile文件">1、多Profile文件</h6>
<p>我们在主配置文件编写的时候，文件名可以是 application-{profile}.properties/yml；</p>
<p>默认使用application.properties的配置</p>
<h6 id="2-yml支持多文档块方式">2、yml支持多文档块方式</h6>
<pre><code class="language-yml">server:
  port: 8081
spring:
  profiles:
    active: dev
---
server:
  port: 8082
spring:
  profiles: dev
---
server:
  port: 8085
spring:
  profiles: prod
#每个文档块属于一个配置
</code></pre>
<h6 id="3-激活指定的profile">3、激活指定的profile</h6>
<p>1、在配置文件中指定 spring.profiles.active=dev</p>
<p>2、命令行：在测试时，配置传入命令行参数--spring.profiles.active=dev</p>
<p>3、虚拟机参数；</p>
<p>​	-Dspring.profiles.active=dev</p>
<h4 id="6-配置文件的位置">6、配置文件的位置</h4>
<p>springboot启动会扫描以下位置的application.properties/application.yml文件：</p>
<p>-file:/config/</p>
<p>-file:/</p>
<p>-classpath:/config/</p>
<p>-classpath:/</p>
<p>优先级高的会覆盖优先级低的，优先级由高到低</p>
<p>Spring Boot会从这四个位置全部加载主配置文件；<strong>互补配置</strong></p>
<p>我们还可以通过spring.config.location来改变默认的配置文件位置</p>
<p><strong>项目打包以后，我们可以使用命令行参数的形式，启动项目的时候指定配置文件的新位置；指定配置文件和默认加载的配置文件共同起作用形成互补配置；</strong></p>
<h4 id="7-外部配置加载顺序">7、外部配置加载顺序</h4>
<p>...</p>
<p>由jar包外向jar包内寻找</p>
<p>优先加载带profile</p>
<h4 id="8-自动配置原理">8、自动配置原理</h4>
<p><a href="https://www.springcloud.cc/spring-boot.html#common-application-properties">配置文件能配置的属性参照</a></p>
<h5 id="1-自动配置原理"><strong>1、自动配置原理</strong>：</h5>
<p>1）、Spring Boot启动时加载主配置类，开启了自动配置功能@EnableAutoConfiguration</p>
<p>2）、@EnableAutoConfiguration的作用：</p>
<ul>
<li>
<p>​	利用AutoConfigurationImportSelector给容器中导入一些组件</p>
</li>
<li>
<p>​    List<String> configurations = SpringFactoriesLoader.loadFactoryNames(this.getSpringFactoriesLoaderFactoryClass(), this.getBeanClassLoader());获取候选配置</p>
<ul>
<li>
<pre><code class="language-java">SpringFactoriesLoader.loadFactoryNames（）
扫描所有jar包类路径下 META-INF/spring.factories
并扫描的这些文件的内容包装成properties对象
从properties中获取EnableAutoConfiguration.class(类名)对应的值，然后把他们添加到容器中
</code></pre>
</li>
</ul>
</li>
</ul>
<p><strong>将类路径下 	META-INF/spring.factories里面配置的所有EnableAutoConfiguration的值添加到容器中</strong></p>
<pre><code class="language-java">org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\
org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\
    ...
</code></pre>
<p>每一个这样的xxxAutoConfiguration类都是容器中的组件，都会加入到容器中；用来自动配置</p>
<p>3）、每一个自动配置类进行自动配置功能</p>
<p>4）、以<strong>HttpEncodingAutoConfiguration</strong>为例解释自动配置原理</p>
<pre><code class="language-java">@Configuration(
    proxyBeanMethods = false
)//表示这是一个配置类
@EnableConfigurationProperties({ServerProperties.class})
//启动指定类的ConfigurationProperties功能；将配置文件中对应的值和HttpEncodingAutoConfiguration的属性进行绑定
@ConditionalOnWebApplication(
    type = Type.SERVLET
)//Spring底层@Conditional注解，根据不同的条件，如果满足指定的条件，整个配置类里面的配置就会生效；判断当前是否是web应用
@ConditionalOnClass({CharacterEncodingFilter.class})//判断当前项目中是否有这个类CharacterEncodingFilter；spring mvc用于解决乱码的过滤器
@ConditionalOnProperty(
    prefix = &quot;server.servlet.encoding&quot;,
    value = {&quot;enabled&quot;},
    matchIfMissing = true
)//判断配置文件中是否存在某个配置 server.servlet.encoding.enabled,（ matchIfMissing = true）即便不存在，也是生效的
public class HttpEncodingAutoConfiguration {
    //他已经和SpringBoot的配置文件影射了  
    private final Encoding properties;
	//只有一个有参构造器的情况下，参数的值会从有参构造其中拿
    public HttpEncodingAutoConfiguration(ServerProperties properties) {
        this.properties = properties.getServlet().getEncoding();
    }

    @Bean	//给容器添加一个组件，这个组件的某些值从properties中获取
    @ConditionalOnMissingBean
    public CharacterEncodingFilter characterEncodingFilter() {
        CharacterEncodingFilter filter = new OrderedCharacterEncodingFilter();
        filter.setEncoding(this.properties.getCharset().name());
        filter.setForceRequestEncoding(this.properties.shouldForce(org.springframework.boot.web.servlet.server.Encoding.Type.REQUEST));
        filter.setForceResponseEncoding(this.properties.shouldForce(org.springframework.boot.web.servlet.server.Encoding.Type.RESPONSE));
        return filter;
    }
}
</code></pre>
<p>根据不同的条件，决定这个配置类是否生效</p>
<p><strong>一旦这个配置类生效；这个配置类就会给容器中添加组件；这些组件的属性是从对应的properties类中获取的，这些类里面的每一个参数又是和配置文件绑定的</strong></p>
<p>精髓：</p>
<p>​	<strong>1）、Spring Boot启动会加载大量的自动配置类</strong></p>
<p>​	<strong>2）、看我们需要的功能有没有Spring Boot默认写好的自动配置类</strong></p>
<p>​	<strong>3）、通过自动配置类给容器中添加组件时，会从properties获取某些属性的值，而这些属性可以通过配置文件指定</strong></p>
<p>xxxAutoConfiguration：自动配置类</p>
<p>给容器中添加组件</p>
<p>xxxProperties：封装配置文件中的相关属性</p>
<h5 id="2-细节">2、细节</h5>
<h6 id="1-conditional派生注解spring注解版原生注解conditional作用">1、@Conditional派生注解（Spring注解版原生注解@Conditional作用）</h6>
<p>作用：必须是@Conditional指定的条件成立，才给容器中添加组件，配置文件里面的内容才会生效</p>
<p>自动配置类生效需要一定的条件，我们可以通过启用debug=true属性；来让控制台打印自动配置报告；</p>
<h2 id="三-日志">三、日志</h2>
<h4 id="1-日志框架">1、日志框架</h4>
<p><strong>市面上的日志框架：</strong></p>
<p>JUL、JCL、Jboss-logging、logback、log4j、log4j2、slf4j...</p>
<table>
<thead>
<tr>
<th>日志门面（日志的抽象层）</th>
<th>日志实现</th>
</tr>
</thead>
<tbody>
<tr>
<td><s><strong>JCL</strong>(Jakarta Commons Logging)</s> <strong>SLF4J</strong>(Simple Logging Facade for Java) <s><strong>jboss-logging</strong></s></td>
<td><strong>Log4j</strong> <strong>JUL</strong>(java.util.logging) <strong>Log4j2</strong> <strong>Logback</strong></td>
</tr>
</tbody>
</table>
<p>日志门面：SLF4J;</p>
<p>日志实现：Logback；</p>
<p>SpringBoot：底层是Spring框架，Spring框架默认是JCL；</p>
<p>​		Spring Boot选用SLF4J和logback；</p>
<h4 id="2-slf4j使用">2、SLF4J使用</h4>
<h5 id="1-如何在系统中使用slf4j">1、如何在系统中使用SLF4j</h5>
<p>以后开发的时候，日志记录的调用，不应该来直接调用日志的实现类，而应该调用抽象层中的方法</p>
<p>给系统里面导入slf4j的jar和logback的jar</p>
<pre><code class="language-java">import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class HelloWorld {
  public static void main(String[] args) {
    Logger logger = LoggerFactory.getLogger(HelloWorld.class);
    logger.info(&quot;Hello World&quot;);
  }
}
</code></pre>
<p>图示<img src="D:%5C%E7%AC%94%E8%AE%B0%5CTypora%5Cviews%5Cconcrete-bindings.png" alt="" loading="lazy"></p>
<p>每一个日志实现框架都有自己的配置文件。使用slf4j以后，配置文件还是做成日志实现框架本身的配置文件</p>
<h5 id="2-遗留问题">2、遗留问题</h5>
<p>a(slf4j+logback)：Spring(commons-logging)、Hibernate(jboss-logging)、xxx</p>
<p>统一日志记录，即使使用别的框架也统一使用slf4j进行输出</p>
<p>图示</p>
<figure data-type="image" tabindex="1"><img src="D:%5C%E7%AC%94%E8%AE%B0%5CTypora%5Cviews%5Clegacy.png" alt="" loading="lazy"></figure>
<p><strong>如何让系统中的所有日志都统一到slf4j</strong></p>
<p>1、排除其他日志框架</p>
<p>2、用中间包替换原有的日志框架</p>
<p>3、导入slf4j其他的实现</p>
<h4 id="3-springboot日志关系">3、SpringBoot日志关系</h4>
<pre><code class="language-xml">&lt;dependency&gt;
      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
      &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;
    &lt;/dependency&gt;
</code></pre>
<p>SpringBoot用它来做日志功能</p>
<pre><code class="language-xml">&lt;dependency&gt;
      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
      &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt;
    &lt;/dependency&gt;
</code></pre>
<p>底层依赖关系</p>
<figure data-type="image" tabindex="2"><img src="C:%5CUsers%5C%E4%B9%90%E3%80%82%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1594550052649.png" alt="1594550052649" loading="lazy"></figure>
<p>总结：</p>
<p>​	1）、SpringBoot底层使用slf4j+logback的方式进行日志记录</p>
<p>​	2）、Spring Boot把其他的日志都替换成了slf4j</p>
<p>​	3）、如果我们要引入其他框架，一定要把这个框架的默认日志依赖移除掉</p>
<p>​	Spring框架使用的是commons-logging;</p>
<figure data-type="image" tabindex="3"><img src="C:%5CUsers%5C%E4%B9%90%E3%80%82%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1594550560519.png" alt="1594550560519" loading="lazy"></figure>
<p>Spring Boot能自动适配所有的日志框架，而且底层使用sl4j+logback的方式记录日志，引入其他框架时，只需将该框架依赖的日志移除</p>
<h4 id="4-日志的使用">4、日志的使用</h4>
<h5 id="1-默认设置">1、默认设置</h5>
<pre><code class="language-java">  //记录器
    private Logger logger = LoggerFactory.getLogger(getClass());
    @Test
    void contextLoads() {

        //日志级别由低到高，可以在配置文件中修改日志的级别
        logger.trace(&quot;this is trace&quot;);
        logger.debug(&quot;this is debug&quot;);
        //SpringBoot默认级别
        logger.info(&quot;this is info&quot;);
        logger.warn(&quot;this is warn&quot;);
        logger.error(&quot;this is error&quot;);
    }
</code></pre>
<pre><code class="language-properties">logging.level.com.example.springbootconfig01=trace
#不指定路径在当前项目下生成日志
logging.file=springboot.log
#在当前磁盘的根路径下创建spring文件夹和里面的log文件夹；使用spring.log作为默认文件
logging.path=/spring/log
</code></pre>
<table>
<thead>
<tr>
<th>logging.file</th>
<th>logging.path</th>
<th>Example</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>none</td>
<td>none</td>
<td></td>
<td>只在控制台输出</td>
</tr>
<tr>
<td>指定文件名</td>
<td>none</td>
<td>my.lpg</td>
<td>输出日志到my.log</td>
</tr>
<tr>
<td>none</td>
<td>指定目录</td>
<td>/var/log</td>
<td>输出到指定目录的spring.log中</td>
</tr>
</tbody>
</table>
<h5 id="2-指定配置">2、指定配置</h5>
<p>在类路径下放上每个日志框架自己的配置即可</p>
<table>
<thead>
<tr>
<th>记录系统</th>
<th>定制</th>
</tr>
</thead>
<tbody>
<tr>
<td>Logback</td>
<td><code>logback-spring.xml</code>, <code>logback-spring.groovy</code>, <code>logback.xml</code>, or <code>logback.groovy</code></td>
</tr>
<tr>
<td>Log4j2</td>
<td><code>log4j2-spring.xml</code> or <code>log4j2.xml</code></td>
</tr>
<tr>
<td>JDK (Java Util Logging)</td>
<td><code>logging.properties</code></td>
</tr>
</tbody>
</table>
<p>logback.xml：直接就被日志框架识别了</p>
<p>logback-spring.xml：日志框架不会直接识别，而由Spring Boot解析日志配置文件，可以使用Spring Boot的高级Profile功能</p>
<pre><code class="language-xml">&lt;springProfile name=&quot;staging&quot;&gt;
	&lt;!-- configuration to be enabled when the &quot;staging&quot; profile is active --&gt;
&lt;/springProfile&gt;

&lt;springProfile name=&quot;dev | staging&quot;&gt;
	&lt;!-- configuration to be enabled when the &quot;dev&quot; or &quot;staging&quot; profiles are active --&gt;
&lt;/springProfile&gt;

&lt;springProfile name=&quot;!production&quot;&gt;
	&lt;!-- configuration to be enabled when the &quot;production&quot; profile is not active --&gt;
&lt;/springProfile&gt;
</code></pre>
<h4 id="5-切换日志框架">5、切换日志框架</h4>
<pre><code class="language-xml">&lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
            &lt;exclusions&gt;
                &lt;exclusion&gt;
                    &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt;
                    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
                &lt;/exclusion&gt;
            &lt;/exclusions&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-log4j2&lt;/artifactId&gt;
        &lt;/dependency&gt;
</code></pre>
<h2 id="四-web开发">四、web开发</h2>
<h4 id="1-简介">1、简介</h4>
<p>自动配置？</p>
<pre><code class="language-java">xxxAutoConfiguration 给容器中自动配置组件
xxxProperties 封装配置文件的类
</code></pre>
<h4 id="2-springboot对静态资源的映射规则">2、SpringBoot对静态资源的映射规则</h4>
<pre><code class="language-java">@EnableConfigurationProperties({WebMvcProperties.class, ResourceProperties.class})
通过点击相应的Properties类查看可以修改的配置
</code></pre>
<pre><code class="language-java">public void addResourceHandlers(ResourceHandlerRegistry registry) {
            if (!this.resourceProperties.isAddMappings()) {
                logger.debug(&quot;Default resource handling disabled&quot;);
            } else {
                Duration cachePeriod = this.resourceProperties.getCache().getPeriod();
                CacheControl cacheControl = this.resourceProperties.getCache().getCachecontrol().toHttpCacheControl();
                if (!registry.hasMappingForPattern(&quot;/webjars/**&quot;)) {
                    this.customizeResourceHandlerRegistration(registry.addResourceHandler(new String[]{&quot;/webjars/**&quot;}).addResourceLocations(new String[]{&quot;classpath:/META-INF/resources/webjars/&quot;}).setCachePeriod(this.getSeconds(cachePeriod)).setCacheControl(cacheControl));
                }

                String staticPathPattern = this.mvcProperties.getStaticPathPattern();
                if (!registry.hasMappingForPattern(staticPathPattern)) {
                    this.customizeResourceHandlerRegistration(registry.addResourceHandler(new String[]{staticPathPattern}).addResourceLocations(WebMvcAutoConfiguration.getResourceLocations(this.resourceProperties.getStaticLocations())).setCachePeriod(this.getSeconds(cachePeriod)).setCacheControl(cacheControl));
                }

            }
        }
</code></pre>
<p>1)、所有的/webjars/**，都去classpath:/META-INF/resources/webjars/下找资源</p>
<p>​	webjars: 以jar包的方式引入静态资源；</p>
<pre><code class="language-xml"> &lt;!-- 引入jquery依赖 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.webjars&lt;/groupId&gt;
            &lt;artifactId&gt;jquery&lt;/artifactId&gt;
            &lt;version&gt;3.3.1-1&lt;/version&gt;
        &lt;/dependency&gt;
</code></pre>
<pre><code class="language-xml">&lt;!--引入bootstrap依赖--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.webjars&lt;/groupId&gt;
            &lt;artifactId&gt;bootstrap&lt;/artifactId&gt;
            &lt;version&gt;4.0.0&lt;/version&gt;
        &lt;/dependency&gt;
</code></pre>
<p>localhost:8080/webjars/jquery/3/3/1/jquery.js</p>
<p>2)、/**访问当前项目的任何资源（静态资源）</p>
<pre><code class="language-java">&quot;classpath:/META-INF/resources/&quot;, &quot;classpath:/resources/&quot;, 
&quot;classpath:/static/&quot;, 
&quot;classpath:/public/&quot;,
&quot;/&quot;:当前项目的根路径
</code></pre>
<p>localhost:8080/abc</p>
<p>3）、欢迎页面；静态资源下的所有index.html页面；被/**映射</p>
<p>​	localhost:8080/找index页面</p>
<p>4）、所有的**/favicon.ico都是在静态资源下找</p>
<h4 id="3-模板引擎">3、模板引擎</h4>
<p>JSP、Velocity、Freemarker、Thymeleaf</p>
<h5 id="1-引入">1、引入</h5>
<pre><code class="language-xml"> 	&lt;dependency&gt;
            					&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;
       &lt;/dependency&gt;
</code></pre>
<h5 id="2-thymeleaf使用语法">2、Thymeleaf使用&amp;语法</h5>
<pre><code class="language-java">@ConfigurationProperties(
    prefix = &quot;spring.thymeleaf&quot;
)
public class ThymeleafProperties {
    private static final Charset DEFAULT_ENCODING;
    public static final String DEFAULT_PREFIX = &quot;classpath:/templates/&quot;;
    public static final String DEFAULT_SUFFIX = &quot;.html&quot;;
</code></pre>
<p>我们只需将html页面放在classpath:/templates/文件夹下，Thymeleaf就可以显然页面</p>
<p>使用时可以导入</p>
<pre><code class="language-html">&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;
</code></pre>
<h5 id="3-语法规则">3、语法规则</h5>
<p>​	1）、th:text;改变当前元素文本内的值</p>
<p>​	th:任意html属性；来替换原生属性的值</p>
<figure data-type="image" tabindex="4"><img src="D:%5C%E7%AC%94%E8%AE%B0%5CTypora%5Cviews%5C1594628896263.png" alt="1594628896263" loading="lazy"></figure>
<p>2）、表达式？</p>
<pre><code class="language-properties">Simple expressions:(简单表达式)
    Variable Expressions: ${...}：获取变量的值，OGNL表达式
    1）、获取对象的属性、调用方法
    2）、使用内置的基本对象：
    	#ctx : the context object.
        #vars: the context variables.
        #locale : the context locale.
        #request : (only in Web Contexts) the HttpServletRequest object.
        #response : (only in Web Contexts) the HttpServletResponse object.
        #session : (only in Web Contexts) the HttpSession object.
        #servletContext : (only in Web Contexts) the ServletContext object.
	2）、内置的一些工具：
	#execInfo : information about the template being processed.
#messages : methods for obtaining externalized messages inside variables expressions, in the same way as theywould be obtained using #{…} syntax.
#uris : methods for escaping parts of URLs/URIs
#conversions : methods for executing the configured conversion service (if any).
#dates : methods for java.util.Date objects: formatting, component extraction, etc.
#calendars : analogous to #dates , but for java.util.Calendar objects.
#numbers : methods for formatting numeric objects.
#strings : methods for String objects: contains, startsWith, prepending/appending, etc.
#objects : methods for objects in general.
#bools : methods for boolean evaluation.
#arrays : methods for arrays.
#lists : methods for lists.
#sets : methods for sets.
#maps : methods for maps.
#aggregates : methods for creating aggregates on arrays or collections.
#ids : methods for dealing with id attributes that might be repeated (for example, as a result of an iteration).
    Selection Variable Expressions: *{...}：功能和${}类似，多了一个功能：和th:object配合使用:
    &lt;div th:object=
    &quot;${session.user}&quot;&gt;
    &lt;p&gt;Name: &lt;span th:text=
    &quot;*{firstName}&quot;&gt;Sebastian&lt;/span&gt;.&lt;/p&gt;
    &lt;p&gt;Surname: &lt;span th:text=
    &quot;*{lastName}&quot;&gt;Pepper&lt;/span&gt;.&lt;/p&gt;
    &lt;p&gt;Nationality: &lt;span th:text=
    &quot;*{nationality}&quot;&gt;Saturn&lt;/span&gt;.&lt;/p&gt;
    &lt;/div&gt;
    
    Message Expressions: #{...}:获取国际化内容
    Link URL Expressions: @{...}:定义url链接: @{/order/process(execId=${execId},execType='FAST')}
    Fragment Expressions: ~{...}:&lt;div th:insert=&quot;~{commons :: main}&quot;&gt;...&lt;/div&gt;
Literals(字面量)
	Text literals: 
        'one text'
        ,
        'Another one!'
        ,…
	Number literals:
		0 , 34 , 3.0 , 12.3 ,…
	Boolean literals: 
		true , false
	Null literal: null
	Literal tokens: one , sometext , main ,…
Text operations:
	String concatenation: +
	Literal substitutions: |The name is ${name}|
Arithmetic operations:
	Binary operators: + ,-,*, / , %
	Minus sign (unary operator): -
Boolean operations:
	Binary operators: and , or
	Boolean negation (unary operator): ! , not
Comparisons and equality:
	Comparators: &gt; , &lt; , &gt;= , &lt;= ( gt , lt , ge , le )
	Equality operators: == , != ( eq , ne )
Conditional operators:
	If-then: (if) ? (then)
	If-then-else: (if) ? (then) : (else)
	Default: (value) ?: (defaultvalue)
Special tokens:
	No-Operation:_

</code></pre>
<h4 id="4-springmvc自动配置">4、SpringMVC自动配置</h4>
<h5 id="1-spring-boot为spring-mvc提供了自动配置">1、Spring Boot为Spring MVC提供了自动配置</h5>
<p>在Spring的默认值之上添加了以下功能：</p>
<ul>
<li>
<p>包含<code>ContentNegotiatingViewResolver</code>和<code>BeanNameViewResolver</code> beans。</p>
<ul>
<li>自动配置了视图解析器（根据方法返回值得到视图对象，视图对象决定如何渲染（转发？重定向））</li>
<li>定制：将我们自定义的视图解析器添加到容器中</li>
</ul>
</li>
<li>
<p>支持提供静态资源，包括对WebJars的支持</p>
</li>
<li>
<p>自动注册<code>Converter</code>，<code>GenericConverter</code>和<code>Formatter</code> beans。</p>
</li>
<li>
<p>支持<code>HttpMessageConverters</code>。</p>
</li>
<li>
<p>自动注册<code>MessageCodesResolver</code>。定义错误代码生成规则</p>
</li>
<li>
<p>静态<code>index.html</code>支持。</p>
</li>
<li>
<p>自定义<code>Favicon</code>支持。</p>
</li>
<li>
<p>自动使用<code>ConfigurableWebBindingInitializer</code> bean</p>
<pre><code class="language-java">初始化WebDataBinder
请求数据===》JavaBean
</code></pre>
</li>
</ul>
<p>如果你想保留Spring Boot MVC功能，并且你想添加额外的 <a href="https://docs.spring.io/spring/docs/5.1.3.RELEASE/spring-framework-reference/web.html#mvc">MVC配置</a>（拦截器，格式化程序，视图控制器和其他功能），你可以添加自己的<code>@Configuration</code>类<code>WebMvcConfigurer</code>类但<strong>没有</strong> <code>@EnableWebMvc</code>。如果您希望提供<code>RequestMappingHandlerMapping</code>，<code>RequestMappingHandlerAdapter</code>或<code>ExceptionHandlerExceptionResolver</code>的自定义实例，则可以声明<code>WebMvcRegistrationsAdapter</code>实例以提供此类组件。</p>
<h5 id="2-扩展springmvc">2、扩展SpringMVC</h5>
<p>编写一个配置类，是<code>WebMvcConfigurer</code>类型的；既保留了原有配置，又添加了扩展配置</p>
<pre><code class="language-java">@Configuration
public class MyWebMvcConfiguration implements WebMvcConfigurer {

    @Override
    public void addViewControllers(ViewControllerRegistry registry) {
        registry.addViewController(&quot;/test&quot;).setViewName(&quot;success&quot;);
    }
}
</code></pre>
<h5 id="3-全面接管springmvc">3、全面接管SpringMVC</h5>
<p><strong>添加@EnableWebMvc</strong></p>
<p>Spring Boot不会再自动配置spring mvc的相关配置，使用的是我们的自己配置的</p>
<pre><code class="language-java">@Configuration
@EnableWebMvc
public class MyWebMvcConfiguration implements WebMvcConfigurer {

    @Override
    public void addViewControllers(ViewControllerRegistry registry) {
        registry.addViewController(&quot;/test&quot;).setViewName(&quot;success&quot;);
    }
}
</code></pre>
<p>原理：</p>
<p>1）</p>
<pre><code class="language-java">@Import({DelegatingWebMvcConfiguration.class})
public @interface EnableWebMvc {...
</code></pre>
<p>2）</p>
<pre><code class="language-java">public class DelegatingWebMvcConfiguration extends WebMvcConfigurationSupport {...
</code></pre>
<p>3）</p>
<pre><code class="language-java">@ConditionalOnMissingBean({WebMvcConfigurationSupport.class})
public class WebMvcAutoConfiguration {...
</code></pre>
<p>4）、@EnableWebMvc将DelegatingWebMvcConfiguration组件导入进来；</p>
<p>5）、导入的DelegatingWebMvcConfiguration知识SpringMVC最基本的功能</p>
<h4 id="5-如何修改spring-boot的默认配置文件">5、如何修改Spring Boot的默认配置文件</h4>
<p>模式;</p>
<p>​	1）、SpringBoot在自动配置很多组件时，会先查看有没有用户配置的，如果有就用用户配置的；如果没有才自动配置；有些组件可以和自己自动配置的组合起来使用</p>
<p>​	2）、在Spring Boot中会有许多xxxConfigurer帮助我们进行扩展配置</p>
<h4 id="6-restfulcrud">6、RestfulCRUD</h4>
<p>​	<strong>使用RestfulCRUD一定要在配置文件中添加：</strong></p>
<pre><code class="language-properties">spring.mvc.hiddenmethod.filter.enabled=true
</code></pre>
<h5 id="1-默认访问页面">1）、默认访问页面</h5>
<pre><code class="language-java">@Configuration
public class MyWebMvcConfiguration implements WebMvcConfigurer {
    @Override
    public void addViewControllers(ViewControllerRegistry registry) {
        registry.addViewController(&quot;/test&quot;).setViewName(&quot;success&quot;);
        registry.addViewController(&quot;/&quot;).setViewName(&quot;login&quot;);
        registry.addViewController(&quot;/login&quot;).setViewName(&quot;login&quot;);
    }
}
</code></pre>
<h5 id="2-国际化">2）、国际化</h5>
<p><strong>1）、编写国际化配置文件</strong></p>
<p>2）、使用ResourceBundleMessageSource管理国际化资源文件</p>
<p>3）、在页面使用fmt:message取出国际化内容</p>
<p>步骤:</p>
<pre><code class="language-properties">spring.messages.basename=i18n/login
</code></pre>
<p>1）、编写国际化配置问价，抽取页面要显示的国际化信息</p>
<p>2）、Spring Boot自动配置好了管理国际化资源文件的组件</p>
<pre><code class="language-java">@Bean
    @ConfigurationProperties(
        prefix = &quot;spring.messages&quot;
    )
    public MessageSourceProperties messageSourceProperties() {
        return new MessageSourceProperties();
    }
    @Bean
    public MessageSource messageSource(MessageSourceProperties properties) {
        ResourceBundleMessageSource messageSource = new ResourceBundleMessageSource();
        if (StringUtils.hasText(properties.getBasename())) {
            messageSource.setBasenames(StringUtils.commaDelimitedListToStringArray(StringUtils.trimAllWhitespace(properties.getBasename())));//设置国际化资源文件基础名（去掉国家语言的文件名）
        }

        if (properties.getEncoding() != null) {
            messageSource.setDefaultEncoding(properties.getEncoding().name());
        }

        messageSource.setFallbackToSystemLocale(properties.isFallbackToSystemLocale());
        Duration cacheDuration = properties.getCacheDuration();
        if (cacheDuration != null) {
            messageSource.setCacheMillis(cacheDuration.toMillis());
        }

        messageSource.setAlwaysUseMessageFormat(properties.isAlwaysUseMessageFormat());
        messageSource.setUseCodeAsDefaultMessage(properties.isUseCodeAsDefaultMessage());
        return messageSource;
    }
</code></pre>
<p>3）、在页面获取对应的值</p>
<p>原理：</p>
<p>​		国际化Local（区域信息对象）；LocaleResolver（获取区域信息对象）；</p>
<pre><code class="language-java">@Bean
        @ConditionalOnMissingBean
        @ConditionalOnProperty(
            prefix = &quot;spring.mvc&quot;,
            name = {&quot;locale&quot;}
        )
        public LocaleResolver localeResolver() {
            if (this.mvcProperties.getLocaleResolver() == org.springframework.boot.autoconfigure.web.servlet.WebMvcProperties.LocaleResolver.FIXED) {
                return new FixedLocaleResolver(this.mvcProperties.getLocale());
            } else {
                AcceptHeaderLocaleResolver localeResolver = new AcceptHeaderLocaleResolver();
                localeResolver.setDefaultLocale(this.mvcProperties.getLocale());
                return localeResolver;
            }
        }
默认就是根据请求头带来的区域信息获取Local进行国际化
</code></pre>
<p>4）、点击链接进行国际化</p>
<pre><code class="language-java">public class MyLocalResolver implements LocaleResolver {
    @Override
    public Locale resolveLocale(HttpServletRequest httpServletRequest) {
        String l = httpServletRequest.getParameter(&quot;l&quot;);

        Locale local = Locale.getDefault();

        if(null!=l){
            String[] s = l.split(&quot;_&quot;);
            local = new Locale(s[0], s[1]);
        }
        return local;
    }
    ...
}
---------------------------
  @Bean
    public LocaleResolver localeResolver(){
        return new MyLocalResolver();
    }//将该组件放入容器中让默认的LocalReslover不被放入容器中

</code></pre>
<h5 id="3-登录">3）、登录</h5>
<p>开发期间模板引擎页面修改以后，要实时生效</p>
<p>​	1）、禁用模板引擎</p>
<p>​	2）、crl+f9：重新编译</p>
<p>​	3）、拦截器</p>
<pre><code class="language-java">public class MyHandlerInterceptor implements HandlerInterceptor {
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        String username = (String) request.getSession().getAttribute(&quot;loginUser&quot;);//可鉴别是否在不同浏览器下登录
        if(!StringUtils.isEmpty(username)){
            return true;
        }else {
            request.setAttribute(&quot;msg&quot;,&quot;没有权限，请先登录&quot;);
            request.getRequestDispatcher(&quot;/index.html&quot;).forward(request,response);//请求转发，若为重定向，则获取不到请求域中msg
            return false;
        }
    }
}
----------------------------------
    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(new MyHandlerInterceptor()).addPathPatterns(&quot;/**&quot;).excludePathPatterns(&quot;/&quot;,&quot;/index.html&quot;,&quot;/user/login&quot;);
    }
</code></pre>
<h5 id="4-crud员工列表">4）、CRUD员工列表</h5>
<p>​	1）、实验的请求架构：</p>
<table>
<thead>
<tr>
<th></th>
<th>url</th>
<th>方式</th>
</tr>
</thead>
<tbody>
<tr>
<td>查询所有员工</td>
<td>emps</td>
<td>GET</td>
</tr>
<tr>
<td>查询某个员工（来到修改页面）</td>
<td>emp/{id}</td>
<td>GET</td>
</tr>
<tr>
<td>来到添加页面</td>
<td>emp</td>
<td>GET</td>
</tr>
<tr>
<td>添加员工</td>
<td>emp</td>
<td>POST</td>
</tr>
<tr>
<td>来到修改页面</td>
<td>emp/{id}</td>
<td>GET</td>
</tr>
<tr>
<td>修改员工</td>
<td>emp</td>
<td>PUT</td>
</tr>
<tr>
<td>删除员工</td>
<td>emp/{id}</td>
<td>DELETE</td>
</tr>
</tbody>
</table>
<p>​	2）、公共部分的抽取</p>
<pre><code class="language-html">1.抽取公共部分
&lt;div th:fragment=
&quot;copy&quot;&gt;
&amp;copy; 2011 The Good Thymes Virtual Grocery
&lt;/div&gt;
2、引入公共片段
&lt;div th:insert=
&quot;
~{footer :: copy}&quot;&gt;&lt;/div&gt;：模板名：：选择器

&lt;div th:insert=
&quot;footer :: copy&quot;&gt;&lt;/div&gt;：模板名：：片段名

</code></pre>
<p>三种引入功能片段的th属性</p>
<p>th:insert:将公共部分整个插入到声明引入的元素中</p>
<p>th:replace:将声明引入的元素换为公共片段</p>
<p>th:include:将公共部份包含要引入的内容</p>
<pre><code>1、引入片段
&lt;footer th:fragment=
&quot;copy&quot;&gt;
&amp;copy; 2011 The Good Thymes Virtual Grocery
&lt;/footer&gt;
2、引入方法
&lt;div th:insert=
&quot;footer :: copy&quot;&gt;&lt;/div&gt;
&lt;div th:replace=
&quot;footer :: copy&quot;&gt;&lt;/div&gt;
&lt;div th:include=
&quot;footer :: copy&quot;&gt;&lt;/div&gt;
3、效果
&lt;div&gt;
&lt;footer&gt;
&amp;copy; 2011 The Good Thymes Virtual Grocery
&lt;/footer&gt;
&lt;/div&gt;

&lt;footer&gt;
&amp;copy; 2011 The Good Thymes Virtual Grocery
&lt;/footer&gt;

&lt;div&gt;
&amp;copy; 2011 The Good Thymes Virtual Grocery
&lt;/div&gt;

</code></pre>
<p>3）、片段高亮：<a href="https://www.bilibili.com/video/BV1Et411Y7tQ?p=38">https://www.bilibili.com/video/BV1Et411Y7tQ?p=38</a></p>
<h4 id="7-错误处理机制">7、错误处理机制</h4>
<h5 id="1-spring-boot默认效果">1）、spring boot默认效果：</h5>
<p>​	通过请求头识别</p>
<p>​	1）、浏览器：返回一个异常页面</p>
<p>​	2）、如果是其他客户端，默认返回一个json数据</p>
<p>原理：</p>
<p>​	1、DefaultErrorAttributes：</p>
<pre><code class="language-java">帮我们在页面上共享信息
public Map&lt;String, Object&gt; getErrorAttributes(WebRequest webRequest, ErrorAttributeOptions options) {
        Map&lt;String, Object&gt; errorAttributes = this.getErrorAttributes(webRequest, options.isIncluded(Include.STACK_TRACE));
        if (this.includeException != null) {
            options = options.including(new Include[]{Include.EXCEPTION});
        }

        if (!options.isIncluded(Include.EXCEPTION)) {
            errorAttributes.remove(&quot;exception&quot;);
        }

        if (!options.isIncluded(Include.STACK_TRACE)) {
            errorAttributes.remove(&quot;trace&quot;);
        }

        if (!options.isIncluded(Include.MESSAGE) &amp;&amp; errorAttributes.get(&quot;message&quot;) != null) {
            errorAttributes.put(&quot;message&quot;, &quot;&quot;);
        }

        if (!options.isIncluded(Include.BINDING_ERRORS)) {
            errorAttributes.remove(&quot;errors&quot;);
        }

        return errorAttributes;
    }
</code></pre>
<p>​	2、BasicErrorController：处理默认/error请求</p>
<pre><code class="language-java">@Controller
@RequestMapping({&quot;${server.error.path:${error.path:/error}}&quot;})

@RequestMapping(
        produces = {&quot;text/html&quot;}//产生html数据，处理浏览器请求
    )
    public ModelAndView errorHtml(HttpServletRequest request, HttpServletResponse response) {
        HttpStatus status = this.getStatus(request);
        Map&lt;String, Object&gt; model = Collections.unmodifiableMap(this.getErrorAttributes(request, this.getErrorAttributeOptions(request, MediaType.TEXT_HTML)));
        response.setStatus(status.value());
        //去哪个页面作为错误页面；包含页面地址和页面内容
        ModelAndView modelAndView = this.resolveErrorView(request, response, status, model);
        return modelAndView != null ? modelAndView : new ModelAndView(&quot;error&quot;, model);
    }

    @RequestMapping//产生json数据处理其他客户端请求
    public ResponseEntity&lt;Map&lt;String, Object&gt;&gt; error(HttpServletRequest request) {
        HttpStatus status = this.getStatus(request);
        if (status == HttpStatus.NO_CONTENT) {
            return new ResponseEntity(status);
        } else {
            Map&lt;String, Object&gt; body = this.getErrorAttributes(request, this.getErrorAttributeOptions(request, MediaType.ALL));
            return new ResponseEntity(body, status);
        }
    }

</code></pre>
<p>​	3、ErrorPageCustomizer：系统出现问题以后来到error请求进行处理</p>
<p>​	4、DefaultErrorViewResolver：</p>
<pre><code class="language-java">public ModelAndView resolveErrorView(HttpServletRequest request, HttpStatus status, Map&lt;String, Object&gt; model) {
        ModelAndView modelAndView = this.resolve(String.valueOf(status.value()), model);
        if (modelAndView == null &amp;&amp; SERIES_VIEWS.containsKey(status.series())) {
            modelAndView = this.resolve((String)SERIES_VIEWS.get(status.series()), model);
        }

        return modelAndView;
    }

    private ModelAndView resolve(String viewName, Map&lt;String, Object&gt; model) {
        //默认Spring Boot可以去找一个页面？error/404
        String errorViewName = &quot;error/&quot; + viewName;
        //模板引擎可以解析这个页面地址就用模板引擎解析
        TemplateAvailabilityProvider provider = this.templateAvailabilityProviders.getProvider(errorViewName, this.applicationContext);
        //模板引擎可用返回errorViewName指定的视图地址；若不可用，返回静态资源文件夹下的errorViewName对应的地址
        return provider != null ? new ModelAndView(errorViewName, model) : this.resolveResource(errorViewName, model);
    }
</code></pre>
<p>步骤：一旦系统出现错误，ErrorPageCustomizer就会生效(定制错误相应规则)；就会来到error请求；就会被BasicErrorController处理；</p>
<p>​	1）、响应页面；去哪个页面是由DefaultErrorViewResolver决定的</p>
<pre><code> protected ModelAndView resolveErrorView(HttpServletRequest request, HttpServletResponse response, HttpStatus status, Map&lt;String, Object&gt; model) {
        Iterator var5 = this.errorViewResolvers.iterator();

        ModelAndView modelAndView;
        do {
            if (!var5.hasNext()) {
                return null;
            }

            ErrorViewResolver resolver = (ErrorViewResolver)var5.next();
            modelAndView = resolver.resolveErrorView(request, status, model);
        } while(modelAndView == null);

        return modelAndView;
    }
</code></pre>
<p>2）、如何定制错误的页面：</p>
<p>​	1）、定制错误的页面；</p>
<p>​		1）、有模板引擎的情况下：error/4xx;；【页面命名为状态码xxx.html】</p>
<p>​		可以使用4xx或者5xx作为错误页面的的文件名;</p>
<p>​		页面能获取的信息：</p>
<p>​				timestamp：时间戳</p>
<p>​				status：状态码</p>
<p>​				error：错误信息</p>
<p>​				exception：异常对象</p>
<p>​				message：异常信息</p>
<p>​				errors：JSR303数据校验的错误</p>
<p>​		2）、没有模板引擎，在静态资源文件夹下static下创建error文件夹</p>
<p>​		3）、以上都没有，默认使用springboot的异常页面</p>
<p>​	2）、定制错误的json数据；</p>
<p>​		1）、可自适应</p>
<pre><code class="language-java">@ControllerAdvice
public class MyExceptionHandler {

    @ExceptionHandler(UserNotExistException.class)
    public String userNotExistException(Map&lt;String,Object&gt; map, HttpServletRequest request){
       // Integer statusCode = (Integer)request.getAttribute(&quot;javax.servlet.error.status_code&quot;);

        request.setAttribute(&quot;javax.servlet.error.status_code&quot;,500);
        map.put(&quot;code&quot;,&quot;user not exist&quot;);
        map.put(&quot;msg&quot;,&quot;用户出错啦&quot;);
        return &quot;forward:/error&quot;;
    }
}

</code></pre>
<p>​		2）、可现实自定义信息</p>
<pre><code class="language-java">@ControllerAdvice
public class MyExceptionHandler {

    @ExceptionHandler(UserNotExistException.class)
    public String userNotExistException(HttpServletRequest request){
       // Integer statusCode = (Integer)request.getAttribute(&quot;javax.servlet.error.status_code&quot;);
        request.setAttribute(&quot;javax.servlet.error.status_code&quot;,500);
        HashMap&lt;String, Object&gt; map = new HashMap&lt;&gt;();
        map.put(&quot;code&quot;,&quot;user not exist&quot;);
        map.put(&quot;msg&quot;,&quot;用户出错啦&quot;);
        request.setAttribute(&quot;ext&quot;,map);
        return &quot;forward:/error&quot;;
    }
}
------------------------------------------
@Component
public class MyErrorAttributes extends DefaultErrorAttributes {

    @Override
    public Map&lt;String, Object&gt; getErrorAttributes(WebRequest webRequest, ErrorAttributeOptions options) {
        Map&lt;String, Object&gt; map = super.getErrorAttributes(webRequest, options);
        map.put(&quot;ext&quot;,webRequest.getAttribute(&quot;ext&quot;,0));
        return map;
    }
}
---------------------------------------------
@Bean
    @ConditionalOnMissingBean(
        value = {ErrorAttributes.class},
        search = SearchStrategy.CURRENT
    )
    public DefaultErrorAttributes errorAttributes() {
        return new DefaultErrorAttributes();
    }

</code></pre>
<h4 id="8配置嵌入式的servlet容器">8.配置嵌入式的Servlet容器</h4>
<p>Spring Boot默认使用tomcat作为嵌入式的tomcat容器</p>
<figure data-type="image" tabindex="5"><img src="D:%5C%E7%AC%94%E8%AE%B0%5CTypora%5Cviews%5C1595128199503.png" alt="1595128199503" loading="lazy"></figure>
<h5 id="1-如何修改和定制servlet容器的相关配置">1）、如何修改和定制Servlet容器的相关配置；</h5>
<p>1、修改和server有关的配置（ServerProperties）</p>
<pre><code class="language-properties">server.port=8080
server.servlet.context-path=/aaa
server.tomcat.uri-encoding=UTF-8
</code></pre>
<p>2、编写一个WebServerFactoryCustomizer：嵌入式的Servlet容器定制器，修改相关配置</p>
<pre><code class="language-java">@Bean
    public WebServerFactoryCustomizer webServerFactoryCustomizer(){
        return new WebServerFactoryCustomizer&lt;TomcatServletWebServerFactory&gt;() {
            @Override
            public void customize(TomcatServletWebServerFactory factory) {
                /*factory.setPort(8085);*/
                Charset uriEncoding = factory.getUriEncoding();
                WebServer webServer = factory.getWebServer();
                System.out.println(uriEncoding);
                System.out.println(webServer);
            }
        };
    }
</code></pre>
<h5 id="2-注册servlet三大组件">2）、注册Servlet三大组件</h5>
<pre><code class="language-properties">ServletRegistrationBean
FilterRegistrationBean
ServletListenerRegistrationBean
</code></pre>
<pre><code class="language-java">public class MyServlet extends HttpServlet {
...
------------------------------------------------
  @Bean
    public ServletRegistrationBean servletRegistrationBean(){
        ServletRegistrationBean bean = new ServletRegistrationBean(new MyServlet(),&quot;/myServlet&quot;);
        return bean;
    }

</code></pre>
<pre><code class="language-java">public class MyFilter implements Filter {
...
----------------------------------------------
 @Bean
    public FilterRegistrationBean filterRegistrationBean(){
        FilterRegistrationBean bean = new FilterRegistrationBean();
        bean.setFilter(new MyFilter());
        bean.setUrlPatterns(Arrays.asList(&quot;/myServlet&quot;));
        return bean;
    }
</code></pre>
<pre><code class="language-java">public class Mylistener implements ServletContextListener {...
------------------------------------------------
@Bean
    public ServletListenerRegistrationBean servletListenerRegistrationBean(){
        ServletListenerRegistrationBean bean = new ServletListenerRegistrationBean();
        bean.setListener(new Mylistener());
        return bean;
    }
</code></pre>
<p>Spring Boot内部配置前端控制器：</p>
<pre><code class="language-java"> @Configuration(
        proxyBeanMethods = false
    )
    @Conditional({DispatcherServletAutoConfiguration.DispatcherServletRegistrationCondition.class})
    @ConditionalOnClass({ServletRegistration.class})
    @EnableConfigurationProperties({WebMvcProperties.class})
    @Import({DispatcherServletAutoConfiguration.DispatcherServletConfiguration.class})
    protected static class DispatcherServletRegistrationConfiguration {
        protected DispatcherServletRegistrationConfiguration() {
        }

        @Bean(
            name = {&quot;dispatcherServletRegistration&quot;}
        )
        @ConditionalOnBean(
            value = {DispatcherServlet.class},
            name = {&quot;dispatcherServlet&quot;}
        )
        public DispatcherServletRegistrationBean dispatcherServletRegistration(DispatcherServlet dispatcherServlet, WebMvcProperties webMvcProperties, ObjectProvider&lt;MultipartConfigElement&gt; multipartConfig) {
        
            DispatcherServletRegistrationBean registration = new DispatcherServletRegistrationBean(dispatcherServlet, webMvcProperties.getServlet().getPath());
            //默认拦截：/ 所有请求，包括静态文件，不包括jsp请求；/*会拦截所有请求，包括jsp请求
            //可以通过spring.mvc.servlet.path=xxx修改前端控制默认拦截请求路径
            registration.setName(&quot;dispatcherServlet&quot;);
            registration.setLoadOnStartup(webMvcProperties.getServlet().getLoadOnStartup());
            multipartConfig.ifAvailable(registration::setMultipartConfig);
            return registration;
        }
    }
</code></pre>
<h5 id="3-替换其他的servlet容器">3）、替换其他的Servlet容器：</h5>
<p>jetty（长连接）、undertow（不支持jsp文件）</p>
<h5 id="4-嵌入式servlet容器自动配置原理">4）、嵌入式Servlet容器自动配置原理:</h5>
<pre><code class="language-java">...
@Override
public EmbeddedServletContainer getEmbeddedServletContainer(
      ServletContextInitializer... initializers) {
    //创建一个Tomcat
   Tomcat tomcat = new Tomcat();
    
    //配置Tomcat的基本环节
   File baseDir = (this.baseDirectory != null ? this.baseDirectory
         : createTempDir(&quot;tomcat&quot;));
   tomcat.setBaseDir(baseDir.getAbsolutePath());
   Connector connector = new Connector(this.protocol);
   tomcat.getService().addConnector(connector);
   customizeConnector(connector);
   tomcat.setConnector(connector);
   tomcat.getHost().setAutoDeploy(false);
   configureEngine(tomcat.getEngine());
   for (Connector additionalConnector : this.additionalTomcatConnectors) {
      tomcat.getService().addConnector(additionalConnector);
   }
   prepareContext(tomcat.getHost(), initializers);
    
    //将配置好的Tomcat传入进去，返回一个EmbeddedServletContainer；并且启动Tomcat服务器
   return getTomcatEmbeddedServletContainer(tomcat);
}
</code></pre>
<p>步骤：</p>
<p>1）、SpringBoot根据导入的依赖情况，给容器中添加相应的EmbeddedServletContainerFactory【TomcatEmbeddedServletContainerFactory】</p>
<p>2）、容器中某个组件要创建对象就会惊动后置处理器；EmbeddedServletContainerCustomizerBeanPostProcessor；</p>
<p>只要是嵌入式的Servlet容器工厂，后置处理器就工作；</p>
<p>3）、后置处理器，从容器中获取所有的<strong>EmbeddedServletContainerCustomizer</strong>，调用定制器的定制方法</p>
<h5 id="5-嵌入式servlet容器启动原理">5）、嵌入式Servlet容器启动原理；</h5>
<p>什么时候创建嵌入式的Servlet容器工厂？什么时候获取嵌入式的Servlet容器并启动Tomcat；</p>
<p>获取嵌入式的Servlet容器工厂：</p>
<p>1）、SpringBoot应用启动运行run方法</p>
<p>2）、refreshContext(context);SpringBoot刷新IOC容器【创建IOC容器对象，并初始化容器，创建容器中的每一个组件】；如果是web应用创建<strong>AnnotationConfigEmbeddedWebApplicationContext</strong>，否则：<strong>AnnotationConfigApplicationContext</strong></p>
<p>3）、refresh(context);<strong>刷新刚才创建好的ioc容器；</strong></p>
<pre><code class="language-java">public void refresh() throws BeansException, IllegalStateException {
   synchronized (this.startupShutdownMonitor) {
      // Prepare this context for refreshing.
      prepareRefresh();

      // Tell the subclass to refresh the internal bean factory.
      ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();

      // Prepare the bean factory for use in this context.
      prepareBeanFactory(beanFactory);

      try {
         // Allows post-processing of the bean factory in context subclasses.
         postProcessBeanFactory(beanFactory);

         // Invoke factory processors registered as beans in the context.
         invokeBeanFactoryPostProcessors(beanFactory);

         // Register bean processors that intercept bean creation.
         registerBeanPostProcessors(beanFactory);

         // Initialize message source for this context.
         initMessageSource();

         // Initialize event multicaster for this context.
         initApplicationEventMulticaster();

         // Initialize other special beans in specific context subclasses.
         onRefresh();

         // Check for listener beans and register them.
         registerListeners();

         // Instantiate all remaining (non-lazy-init) singletons.
         finishBeanFactoryInitialization(beanFactory);

         // Last step: publish corresponding event.
         finishRefresh();
      }

      catch (BeansException ex) {
         if (logger.isWarnEnabled()) {
            logger.warn(&quot;Exception encountered during context initialization - &quot; +
                  &quot;cancelling refresh attempt: &quot; + ex);
         }

         // Destroy already created singletons to avoid dangling resources.
         destroyBeans();

         // Reset 'active' flag.
         cancelRefresh(ex);

         // Propagate exception to caller.
         throw ex;
      }

      finally {
         // Reset common introspection caches in Spring's core, since we
         // might not ever need metadata for singleton beans anymore...
         resetCommonCaches();
      }
   }
}
</code></pre>
<p>4）、  onRefresh(); web的ioc容器重写了onRefresh方法</p>
<p>5）、webioc容器会创建嵌入式的Servlet容器；<strong>createEmbeddedServletContainer</strong>();</p>
<p><strong>6）、获取嵌入式的Servlet容器工厂：</strong></p>
<p>EmbeddedServletContainerFactory containerFactory = getEmbeddedServletContainerFactory();</p>
<p>​	从ioc容器中获取EmbeddedServletContainerFactory 组件；<strong>TomcatEmbeddedServletContainerFactory</strong>创建对象，后置处理器一看是这个对象，就获取所有的定制器来先定制Servlet容器的相关配置；</p>
<p>7）、<strong>使用容器工厂获取嵌入式的Servlet容器</strong>：this.embeddedServletContainer = containerFactory      .getEmbeddedServletContainer(getSelfInitializer());</p>
<p>8）、嵌入式的Servlet容器创建对象并启动Servlet容器；</p>
<p><strong>先启动嵌入式的Servlet容器，再将ioc容器中剩下没有创建出的对象获取出来；</strong></p>
<p><strong><mark>IOC容器启动创建嵌入式的Servlet容器</mark></strong></p>
<h4 id="9-使用外置的servlet容器">9、使用外置的Servlet容器</h4>
<p>嵌入式Servlet容器：应用打成可执行jar</p>
<p>​		优点：简单、便捷</p>
<p>​		缺点：默认不支持JSP、优化定制比较复杂</p>
<p>外置的Servlet容器：外面安装Tomcat--应用war包的方式打包</p>
<p>步骤：</p>
<p>1）、必须创建一个war项目（利用idea创建好目录结构）</p>
<p>2）、将嵌入式的Tomcat指定为Provided；</p>
<pre><code class="language-java">&lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;
            &lt;scope&gt;provided&lt;/scope&gt;
        &lt;/dependency&gt;
</code></pre>
<p>3）、必须编写一个SpringBootServletInitializer的子类，并调用configure方法</p>
<pre><code class="language-java">public class ServletInitializer extends SpringBootServletInitializer {

    @Override
    protected SpringApplicationBuilder configure(SpringApplicationBuilder application) {
        //传入Spring Boot的主应用程序
        return application.sources(SpringBootWebJspApplication.class);
    }

}

</code></pre>
<p>4）、启动服务器</p>
<h3 id="原理">原理</h3>
<p>jar包：执行SpringBoot主类的main方法，启动ioc容器，创建嵌入式的Servlet容器；</p>
<p>war包：启动服务器，<strong>服务器启动SpringBoot应用</strong>【SpringBootServletInitializer】，启动ioc容器；</p>
<p>servlet3.0（Spring注解版）：</p>
<p>8.2.4 Shared libraries / runtimes pluggability：</p>
<p>规则：</p>
<p>​	1）、服务器启动（web应用启动）会创建当前web应用里面每一个jar包里面ServletContainerInitializer实例：</p>
<p>​	2）、ServletContainerInitializer的实现放在jar包的META-INF/services文件夹下，有一个名为javax.servlet.ServletContainerInitializer的文件，内容就是ServletContainerInitializer的实现类的全类名</p>
<p>​	3）、还可以使用@HandlesTypes，在应用启动的时候加载我们感兴趣的类；</p>
<p>流程：</p>
<p>1）、启动Tomcat</p>
<p>2）、org\springframework\spring-web\4.3.14.RELEASE\spring-web-4.3.14.RELEASE.jar!\META-INF\services\javax.servlet.ServletContainerInitializer：</p>
<p>Spring的web模块里面有这个文件：<strong>org.springframework.web.SpringServletContainerInitializer</strong></p>
<p>3）、SpringServletContainerInitializer将@HandlesTypes(WebApplicationInitializer.class)标注的所有这个类型的类都传入到onStartup方法的Set&lt;Class&lt;?&gt;&gt;；为这些WebApplicationInitializer类型的类创建实例；</p>
<p>4）、每一个WebApplicationInitializer都调用自己的onStartup；</p>
<p>![](D:/笔记/Typora/Spring Boot 笔记+课件/images/搜狗截图20180302221835.png)</p>
<p>5）、相当于我们的SpringBootServletInitializer的类会被创建对象，并执行onStartup方法</p>
<p>6）、SpringBootServletInitializer实例执行onStartup的时候会createRootApplicationContext；创建容器</p>
<pre><code class="language-java">protected WebApplicationContext createRootApplicationContext(
      ServletContext servletContext) {
    //1、创建SpringApplicationBuilder
   SpringApplicationBuilder builder = createSpringApplicationBuilder();
   StandardServletEnvironment environment = new StandardServletEnvironment();
   environment.initPropertySources(servletContext, null);
   builder.environment(environment);
   builder.main(getClass());
   ApplicationContext parent = getExistingRootWebApplicationContext(servletContext);
   if (parent != null) {
      this.logger.info(&quot;Root context already created (using as parent).&quot;);
      servletContext.setAttribute(
            WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, null);
      builder.initializers(new ParentContextApplicationContextInitializer(parent));
   }
   builder.initializers(
         new ServletContextApplicationContextInitializer(servletContext));
   builder.contextClass(AnnotationConfigEmbeddedWebApplicationContext.class);
    
    //调用configure方法，子类重写了这个方法，将SpringBoot的主程序类传入了进来
   builder = configure(builder);
    
    //使用builder创建一个Spring应用
   SpringApplication application = builder.build();
   if (application.getSources().isEmpty() &amp;&amp; AnnotationUtils
         .findAnnotation(getClass(), Configuration.class) != null) {
      application.getSources().add(getClass());
   }
   Assert.state(!application.getSources().isEmpty(),
         &quot;No SpringApplication sources have been defined. Either override the &quot;
               + &quot;configure method or add an @Configuration annotation&quot;);
   // Ensure error pages are registered
   if (this.registerErrorPageFilter) {
      application.getSources().add(ErrorPageFilterConfiguration.class);
   }
    //启动Spring应用
   return run(application);
}
</code></pre>
<p>7）、Spring的应用就启动并且创建IOC容器</p>
<pre><code class="language-java">public ConfigurableApplicationContext run(String... args) {
   StopWatch stopWatch = new StopWatch();
   stopWatch.start();
   ConfigurableApplicationContext context = null;
   FailureAnalyzers analyzers = null;
   configureHeadlessProperty();
   SpringApplicationRunListeners listeners = getRunListeners(args);
   listeners.starting();
   try {
      ApplicationArguments applicationArguments = new DefaultApplicationArguments(
            args);
      ConfigurableEnvironment environment = prepareEnvironment(listeners,
            applicationArguments);
      Banner printedBanner = printBanner(environment);
      context = createApplicationContext();
      analyzers = new FailureAnalyzers(context);
      prepareContext(context, environment, listeners, applicationArguments,
            printedBanner);
       
       //刷新IOC容器
      refreshContext(context);
      afterRefresh(context, applicationArguments);
      listeners.finished(context, null);
      stopWatch.stop();
      if (this.logStartupInfo) {
         new StartupInfoLogger(this.mainApplicationClass)
               .logStarted(getApplicationLog(), stopWatch);
      }
      return context;
   }
   catch (Throwable ex) {
      handleRunFailure(context, listeners, analyzers, ex);
      throw new IllegalStateException(ex);
   }
}
</code></pre>
<p><strong><mark>启动Servlet容器，再启动SpringBoot应用</mark></strong></p>
<h2 id="五-dockers">五、Dockers</h2>
<h4 id="1-简介-2">1、简介</h4>
<p><strong>Docker</strong>是一个开源的应用容器引擎；是一个轻量级容器技术；</p>
<p>Docker支持将软件编译成一个镜像；然后在镜像中各种软件做好配置，将镜像发布出去，其他使用者可以直接使用这个镜像；</p>
<p>运行中的这个镜像称为容器，容器启动是非常快速的。</p>
<p>![](D:/笔记/Typora/Spring Boot 笔记+课件/images/搜狗截图20180303145450.png)</p>
<p>![](D:/笔记/Typora/Spring Boot 笔记+课件/images/搜狗截图20180303145531.png)</p>
<h4 id="2-核心概念">2、核心概念</h4>
<p>docker主机(Host)：安装了Docker程序的机器（Docker直接安装在操作系统之上）；</p>
<p>docker客户端(Client)：连接docker主机进行操作；</p>
<p>docker仓库(Registry)：用来保存各种打包好的软件镜像；</p>
<p>docker镜像(Images)：软件打包好的镜像；放在docker仓库中；</p>
<p>docker容器(Container)：镜像启动后的实例称为一个容器；容器是独立运行的一个或一组应用</p>
<p>![](D:/笔记/Typora/Spring Boot 笔记+课件/images/搜狗截图20180303165113.png)</p>
<p>使用Docker的步骤：</p>
<p>1）、安装Docker</p>
<p>2）、去Docker仓库找到这个软件对应的镜像；</p>
<p>3）、使用Docker运行这个镜像，这个镜像就会生成一个Docker容器；</p>
<p>4）、对容器的启动停止就是对软件的启动停止；</p>
<h4 id="3-安装docker">3、安装Docker</h4>
<h5 id="1-安装linux虚拟机">1）、安装linux虚拟机</h5>
<p>​	1）、VMWare、VirtualBox（安装）；</p>
<p>​	2）、导入虚拟机文件centos7-atguigu.ova；</p>
<p>​	3）、双击启动linux虚拟机；使用root/123456登录</p>
<p>​	4）、使用客户端连接linux服务器进行命令操作；</p>
<p>​	5）、设置虚拟机网络</p>
<p>​		桥接网络-》选好网卡-》接入网线</p>
<p>​	6）、设置好网络以后使用命令重启虚拟机网络</p>
<pre><code class="language-shell">service network restart
</code></pre>
<p>​	7）、查看linux的ip地址</p>
<pre><code class="language-shell">ip addr
</code></pre>
<p>8）、使用客户端连接</p>
<h5 id="2-在linux虚拟机上安装docker">2）、在Linux虚拟机上安装docker</h5>
<p>步骤：</p>
<pre><code>1.安装：
yum install docker
2.启动
systemctl start docker
查看版本号：docker -v
3.开机后启动
systemctl enable docker
4.关闭docker
close docker
</code></pre>
<h4 id="4-docker常用命令操作">4、Docker常用命令&amp;操作</h4>
<h5 id="1-镜像操作">1）、镜像操作</h5>
<table>
<thead>
<tr>
<th>操作</th>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>检索</td>
<td>docker  search 关键字  eg：docker  search redis</td>
<td>我们经常去docker  hub上检索镜像的详细信息，如镜像的TAG。</td>
</tr>
<tr>
<td>拉取</td>
<td>docker pull 镜像名:tag</td>
<td>:tag是可选的，tag表示标签，多为软件的版本，默认是latest</td>
</tr>
<tr>
<td>列表</td>
<td>docker images</td>
<td>查看所有本地镜像</td>
</tr>
<tr>
<td>删除</td>
<td>docker rmi image-id</td>
<td>删除指定的本地镜像</td>
</tr>
</tbody>
</table>
<p>https://hub.docker.com/</p>
<h2 id="六-spring-boot与数据访问">六、Spring Boot与数据访问</h2>
<h4 id="1-jdbc">1、JDBC</h4>
<pre><code class="language-xml">		&lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-data-jdbc&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;mysql&lt;/groupId&gt;
            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
            &lt;scope&gt;runtime&lt;/scope&gt;
        &lt;/dependency&gt;
</code></pre>
<pre><code class="language-yml">spring:
  datasource:
    password: lizhuo21321
    driver-class-name: com.mysql.cj.jdbc.Driver
    url: jdbc:mysql://localhost/mybatis?serverTimezone=Asia/Shanghai
    username: root
</code></pre>
<p>效果：</p>
<p>​	默认使用的是：com.zaxxer.hikari.HikariDataSource作为数据源</p>
<p>​		获取到的连接：HikariProxyConnection@1720760826 wrapping com.mysql.cj.jdbc.ConnectionImpl@6c8dbf56</p>
<p><strong>自动配置原理</strong>：</p>
<p>1）、可以使用spring.datasource.type指定自定义的数据源</p>
<p>2）、springboot默认可以支持：</p>
<pre><code class="language-java">org.apache.tomcat.jdbc.pool.DataSource、BasicDataSource（dbcp2）、HikariDataSource
</code></pre>
<p>自定义数据源</p>
<pre><code class="language-java">@Configuration(
        proxyBeanMethods = false
    )
    @ConditionalOnMissingBean({DataSource.class})
    @ConditionalOnProperty(
        name = {&quot;spring.datasource.type&quot;}
    )
    static class Generic {
        Generic() {
        }

        @Bean
        DataSource dataSource(DataSourceProperties properties) {
            return properties.initializeDataSourceBuilder().build();
        }
    }

</code></pre>
<pre><code class="language-properties">JdbcTemplate：数据访问
</code></pre>
<h4 id="2-整合druid">2、整合Druid</h4>
<h4 id="不加log4j依赖就会报错">（不加log4j依赖就会报错）</h4>
<pre><code class="language-xml"> &lt;!--引入DruidDataSource--&gt;
        &lt;!-- https://mvnrepository.com/artifact/com.alibaba/druid --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
            &lt;artifactId&gt;druid&lt;/artifactId&gt;
            &lt;version&gt;1.1.23&lt;/version&gt;
        &lt;/dependency&gt;
		
        &lt;!-- https://mvnrepository.com/artifact/log4j/log4j --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;log4j&lt;/groupId&gt;
            &lt;artifactId&gt;log4j&lt;/artifactId&gt;
            &lt;version&gt;1.2.17&lt;/version&gt;
        &lt;/dependency&gt;
</code></pre>
<pre><code class="language-yml">spring:
  datasource:
    password: lizhuo21321
    driver-class-name: com.mysql.cj.jdbc.Driver
    url: jdbc:mysql://localhost/mybatis?serverTimezone=Asia/Shanghai
    username: root
    type: com.alibaba.druid.pool.DruidDataSource

    initialSize: 5
    minIdle: 5
    maxActive: 20
    maxWait: 60000
    timeBetweenEvictionRunsMillis: 60000
    minEvictableIdleTimeMillis: 300000
    validationQuery: SELECT 1 FROM DUAL
    testWhileIdle: true
    testOnBorrow: false
    testOnReturn: false
    poolPreparedStatements: true
    #   配置监控统计拦截的filters，去掉后监控界面sql无法统计，'wall'用于防火墙
    filters: stat,wall,log4j
    maxPoolPreparedStatementPerConnectionSize: 20
    useGlobalDataSourceStat: true
    connectionProperties: druid.stat.mergeSql=true;druid.stat.slowSqlMillis=500

</code></pre>
<pre><code class="language-java">//将配置与DruidDataSource绑定
@Configuration
public class DruidConfig {


    @Bean
    @ConfigurationProperties(prefix = &quot;spring.datasource&quot;)
    public DataSource druid(){
        return new DruidDataSource();
    }

    //配置Druid的监控
    //1、配置一个管理后台的Servlet
    @Bean
    public ServletRegistrationBean statViewServlet(){
        ServletRegistrationBean bean = new ServletRegistrationBean(new StatViewServlet(),&quot;/druid/*&quot;);
        Map&lt;String,String&gt; initParams = new HashMap&lt;&gt;();
        initParams.put(&quot;loginUsername&quot;,&quot;admin&quot;);
        initParams.put(&quot;loginPassword&quot;,&quot;123456&quot;);
        initParams.put(&quot;allow&quot;,&quot;&quot;);//默认允许所有访问
        initParams.put(&quot;deny&quot;,&quot;192.168.15.21&quot;);

        bean.setInitParameters(initParams);
        return bean;
    }
    //2、配置一个web监控的filter
    @Bean
    public FilterRegistrationBean webStatFilter(){
        FilterRegistrationBean bean = new FilterRegistrationBean();
        bean.setFilter(new WebStatFilter());
        Map&lt;String,String&gt; initParams = new HashMap&lt;&gt;();
        initParams.put(&quot;exclusions&quot;,&quot;*.js,*.css,/druid/*&quot;);

        bean.setInitParameters(initParams);

        bean.setUrlPatterns(Arrays.asList(&quot;/*&quot;));
        return bean;
    }
}

</code></pre>
<h4 id="3-整合mybatis">3、整合Mybatis</h4>
<figure data-type="image" tabindex="6"><img src="D:%5C%E7%AC%94%E8%AE%B0%5CTypora%5Cviews%5C1594871951150.png" alt="1594871951150" loading="lazy"></figure>
<p>配置文件版</p>
<pre><code class="language-properties">mybatis.config-location=classpath:mybatis/mybatis-config.xml
mybatis.mapper-locations=classpath:mybatis/mapper/*Mapper.xml
mybatis.type-aliases-package=com.example.springboot.bean
</code></pre>
<img src="C:\Users\乐。\AppData\Roaming\Typora\typora-user-images\1594882132606.png" alt="1594882132606" style="zoom: 50%;" />
<h4 id="4-整合springdata-jpa">4、整合SpringData JPA</h4>
<h5 id="1-简介-3">1）、简介<img src="D:%5C%E7%AC%94%E8%AE%B0%5CTypora%5Cviews%5C1594882320276.png" alt="1594882320276" loading="lazy"></h5>
<h5 id="2-整合springdatajpa">2）、整合SpringDataJPA</h5>
<p>JPA:ORM（Object Relational Mapping）；<br>
1）、编写一个实体类（bean）和数据表进行映射，并且配置好映射关系；</p>
<pre><code class="language-java">//使用JPA注解配置映射关系
@Entity //告诉JPA这是一个实体类（和数据表映射的类）
@Table(name =
&quot;tbl
_
user&quot;) //@Table来指定和哪个数据表对应;如果省略默认表名就是user；
public class User {
@Id //这是一个主键
@GeneratedValue(strategy = GenerationType.IDENTITY)//自增主键
private Integer id;
@Column(name =
&quot;last
_
name&quot;
,length = 50) //这是和数据表对应的一个列
private String lastName;
@Column //省略默认列名就是属性名
private String email;

</code></pre>
<p>2）、编写一个DAO接口来操作实体类对应的数据表（Reposity）</p>
<pre><code class="language-java">//继承JpaRepository来完成对数据库的操作
public interface UserRepository extends JpaRepository&lt;User,Integer&gt; {
}

</code></pre>
<p>3）、基本的Properties</p>
<pre><code class="language-properties">spring:
jpa:
hibernate:
# 更新或者创建数据表结构
ddl‐auto: update
# 控制台显示SQL
show‐sql: true

</code></pre>
<h2 id="七-启动配置原理">七、启动配置原理</h2>
<p>几个重要的事件回调机制</p>
<p>配置在META-INF/spring.factories</p>
<p><strong>ApplicationContextInitializer</strong></p>
<p><strong>SpringApplicationRunListener</strong></p>
<p>只需要放在ioc容器中</p>
<p><strong>ApplicationRunner</strong></p>
<p><strong>CommandLineRunner</strong></p>
<p>启动流程</p>
<h4 id="1-创建springapplication对象"><strong>1、创建SpringApplication对象</strong></h4>
<pre><code class="language-java">initialize(sources);
private void initialize(Object[] sources) {
    //保存主配置类
    if (sources != null &amp;&amp; sources.length &gt; 0) {
        this.sources.addAll(Arrays.asList(sources));
    }
    //判断当前是否一个web应用
    this.webEnvironment = deduceWebEnvironment();
    //从类路径下找到META-INF/spring.factories配置的所有ApplicationContextInitializer；然后保存起来
    setInitializers((Collection) getSpringFactoriesInstances(
        ApplicationContextInitializer.class));
    //从类路径下找到ETA-INF/spring.factories配置的所有ApplicationListener
    setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));
    //从多个配置类中找到有main方法的主配置类
    this.mainApplicationClass = deduceMainApplicationClass();
}
</code></pre>
<p>![](D:/笔记/Typora/Spring Boot 笔记+课件/images/搜狗截图20180306145727.png)</p>
<p>![](D:/笔记/Typora/Spring Boot 笔记+课件/images/搜狗截图20180306145855.png)</p>
<h4 id="2-运行run方法">2）、运行run方法</h4>
<pre><code class="language-java">public ConfigurableApplicationContext run(String... args) {
        StopWatch stopWatch = new StopWatch();
        stopWatch.start();
        ConfigurableApplicationContext context = null;
        Collection&lt;SpringBootExceptionReporter&gt; exceptionReporters = new ArrayList();
        this.configureHeadlessProperty();
    //获取SpringApplicationRunListeners;从类路径下META-INF/spring.factories
        SpringApplicationRunListeners listeners = this.getRunListeners(args);
    //回调所有的SpringApplicationRunListener.starting()方法
        listeners.starting();

        Collection exceptionReporters;
        try {
            //封装命令行参数
            ApplicationArguments applicationArguments = new DefaultApplicationArguments(args);
            //准备环境
            ConfigurableEnvironment environment = this.prepareEnvironment(listeners, applicationArguments);//创建环境完成后回调SpringApplicationRunListener.environmentPrepared()方法，表示环境创建完成
            this.configureIgnoreBeanInfo(environment);
            Banner printedBanner = this.printBanner(environment);
            //创建ApplicationContext；决定创建web的ioc还是普通的ioc
            context = this.createApplicationContext();
            exceptionReporters = this.getSpringFactoriesInstances(SpringBootExceptionReporter.class, new Class[]{ConfigurableApplicationContext.class}, context);
            //准备上下文环境;将environment保存到ioc中；而且applyInitializers()；
       //applyInitializers()：回调之前保存的所有的ApplicationContextInitializer的initialize方法
       //回调所有的SpringApplicationRunListener的contextPrepared()；
       //
            this.prepareContext(context, environment, listeners, applicationArguments, printedBanner);
              //prepareContext运行完成以后回调所有的SpringApplicationRunListener的contextLoaded（）；
            //s刷新容器；ioc容器初始化（如果是web应用还会创建嵌入式的Tomcat）；Spring注解版
       //扫描，创建，加载所有组件的地方；（配置类，组件，自动配置）
            this.refreshContext(context);
            //从ioc容器中获取所有的ApplicationRunner和CommandLineRunner进行回调
       //ApplicationRunner先回调，CommandLineRunner再回调
            this.afterRefresh(context, applicationArguments);
            stopWatch.stop();
            if (this.logStartupInfo) {
                (new StartupInfoLogger(this.mainApplicationClass)).logStarted(this.getApplicationLog(), stopWatch);
            }

            listeners.started(context);
            this.callRunners(context, applicationArguments);
        } catch (Throwable var10) {
            this.handleRunFailure(context, var10, exceptionReporters, listeners);
            throw new IllegalStateException(var10);
        }

        try {
            listeners.running(context);
            return context;
        } catch (Throwable var9) {
            this.handleRunFailure(context, var9, exceptionReporters, (SpringApplicationRunListeners)null);
            throw new IllegalStateException(var9);
        }
    }
</code></pre>
<h4 id="3-事件监听机制">3）、事件监听机制</h4>
<p>配置在META-INF/spring.factories</p>
<p><strong>ApplicationContextInitializer</strong></p>
<pre><code class="language-java">public class HelloApplicationContextInitializer implements ApplicationContextInitializer&lt;ConfigurableApplicationContext&gt; {
    @Override
    public void initialize(ConfigurableApplicationContext applicationContext) {
        System.out.println(&quot;ApplicationContextInitializer...initialize...&quot;+applicationContext);
    }
}

</code></pre>
<p><strong>SpringApplicationRunListener</strong></p>
<pre><code class="language-java">public class HelloSpringApplicationRunListener implements SpringApplicationRunListener {

    //必须有的构造器
    public HelloSpringApplicationRunListener(SpringApplication application, String[] args){

    }

    @Override
    public void starting() {
        System.out.println(&quot;SpringApplicationRunListener...starting...&quot;);
    }

    @Override
    public void environmentPrepared(ConfigurableEnvironment environment) {
        Object o = environment.getSystemProperties().get(&quot;os.name&quot;);
        System.out.println(&quot;SpringApplicationRunListener...environmentPrepared..&quot;+o);
    }

    @Override
    public void contextPrepared(ConfigurableApplicationContext context) {
        System.out.println(&quot;SpringApplicationRunListener...contextPrepared...&quot;);
    }

    @Override
    public void contextLoaded(ConfigurableApplicationContext context) {
        System.out.println(&quot;SpringApplicationRunListener...contextLoaded...&quot;);
    }

    @Override
    public void finished(ConfigurableApplicationContext context, Throwable exception) {
        System.out.println(&quot;SpringApplicationRunListener...finished...&quot;);
    }
}

</code></pre>
<p>只需要放在ioc容器中</p>
<pre><code class="language-properties">org.springframework.context.ApplicationContextInitializer=\
com.atguigu.springboot.listener.HelloApplicationContextInitializer

org.springframework.boot.SpringApplicationRunListener=\
com.atguigu.springboot.listener.HelloSpringApplicationRunListener
</code></pre>
<p><strong>ApplicationRunner</strong></p>
<pre><code class="language-java">@Component
public class HelloApplicationRunner implements ApplicationRunner {
    @Override
    public void run(ApplicationArguments args) throws Exception {
        System.out.println(&quot;ApplicationRunner...run....&quot;);
    }
}
</code></pre>
<p><strong>CommandLineRunner</strong></p>
<pre><code class="language-java">@Component
public class HelloCommandLineRunner implements CommandLineRunner {
    @Override
    public void run(String... args) throws Exception {
        System.out.println(&quot;CommandLineRunner...run...&quot;+ Arrays.asList(args));
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[test]]></title>
        <id>https://lz-00.github.io/blog/post/test/</id>
        <link href="https://lz-00.github.io/blog/post/test/">
        </link>
        <updated>2021-04-15T16:08:47.000Z</updated>
        <content type="html"><![CDATA[<p>Demo</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Demo]]></title>
        <id>https://lz-00.github.io/blog/post/demo/</id>
        <link href="https://lz-00.github.io/blog/post/demo/">
        </link>
        <updated>2021-04-15T16:08:10.000Z</updated>
        <content type="html"><![CDATA[<p>Test</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hello Gridea]]></title>
        <id>https://lz-00.github.io/blog/post/hello-gridea/</id>
        <link href="https://lz-00.github.io/blog/post/hello-gridea/">
        </link>
        <updated>2018-12-11T16:00:00.000Z</updated>
        <summary type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
]]></summary>
        <content type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
<!-- more -->
<p><a href="https://github.com/getgridea/gridea">Github</a><br>
<a href="https://gridea.dev/">Gridea 主页</a><br>
<a href="http://fehey.com/">示例网站</a></p>
<h2 id="特性">特性👇</h2>
<p>📝  你可以使用最酷的 <strong>Markdown</strong> 语法，进行快速创作</p>
<p>🌉  你可以给文章配上精美的封面图和在文章任意位置插入图片</p>
<p>🏷️  你可以对文章进行标签分组</p>
<p>📋  你可以自定义菜单，甚至可以创建外部链接菜单</p>
<p>💻  你可以在 <strong>Windows</strong>，<strong>MacOS</strong> 或 <strong>Linux</strong> 设备上使用此客户端</p>
<p>🌎  你可以使用 <strong>𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌</strong> 或 <strong>Coding Pages</strong> 向世界展示，未来将支持更多平台</p>
<p>💬  你可以进行简单的配置，接入 <a href="https://github.com/gitalk/gitalk">Gitalk</a> 或 <a href="https://github.com/SukkaW/DisqusJS">DisqusJS</a> 评论系统</p>
<p>🇬🇧  你可以使用<strong>中文简体</strong>或<strong>英语</strong></p>
<p>🌁  你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力</p>
<p>🖥  你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步</p>
<p>🌱 当然 <strong>Gridea</strong> 还很年轻，有很多不足，但请相信，它会不停向前 🏃</p>
<p>未来，它一定会成为你离不开的伙伴</p>
<p>尽情发挥你的才华吧！</p>
<p>😘 Enjoy~</p>
]]></content>
    </entry>
</feed>